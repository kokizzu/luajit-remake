#pragma once

#include "common_utils.h"

// 1-15 byte x86-64 NOP instruction sequences
// Note that all sequences are padded to 16 bytes to make addressing easier
//
inline constexpr std::array<uint8_t, 15 * 16> x_x64_multi_byte_nop_instruction_seq_table = {
    // From Intel's Manual:
    //    https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2b-manual.pdf
    //    Page 165, table 4-12, "Recommended Multi-Byte Sequence of NOP Instruction"
    //
    // AMD Manual recommends the same byte sequence.
    //
    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x1F, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x1F, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // NOP 10-15: we use the NOP sequence from JavaScriptCore, see
    //     https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/assembler/X86Assembler.h.html#3990
    //
    0x66, 0x2e, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x66, 0x2e, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x66, 0x66, 0x2e, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x66, 0x66, 0x66, 0x2e, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x66, 0x66, 0x66, 0x66, 0x2e, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x2e, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00
};

inline const uint8_t* WARN_UNUSED GetX64MultiByteNOPInst(size_t instLength)
{
    TestAssert(1 <= instLength && instLength <= 15);
    return x_x64_multi_byte_nop_instruction_seq_table.data() + (instLength - 1) * 16;
}

// Populate multi-byte NOP instruction to an address range
//
inline void FillAddressRangeWithX64MultiByteNOPs(uint8_t* addr, size_t length)
{
    while (length > 0)
    {
        size_t instLen = 15;
        instLen = std::min(instLen, length);
        memcpy(addr, GetX64MultiByteNOPInst(instLen), instLen);
        length -= instLen;
        addr += instLen;
    }
}
