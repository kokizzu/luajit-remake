#pragma once

#include "common_utils.h"
#include "tvalue.h"
#include "temp_arena_allocator.h"

// This header file is included by bytecode_builder_utils.h to provide necessary data format
// definitions to the generated bytecode accessor functions
//

// The data format used for nodes with non-trivial use of ranged operands
// Layout:
// [ RangeInfo... ] [ NodePropagationRule ] [ predictions... ]
//
struct DfgComplexNodePredictionPropagationData
{
    struct RangeInfo
    {
        uint16_t m_outputOffset;
        uint16_t m_rangeOffset;
        uint16_t m_numValues;
    };

    RangeInfo* ALWAYS_INLINE GetRangeInfo(size_t idx)
    {
        return reinterpret_cast<RangeInfo*>(this) - (idx + 1);
    }

    static DfgComplexNodePredictionPropagationData* WARN_UNUSED Create(TempArenaAllocator& alloc,
                                                                       size_t numRangeInfos,
                                                                       size_t numOutputs)
    {
        TestAssert(numOutputs > 0);
        size_t presize = RoundUpToMultipleOf<alignof(TypeMaskTy)>(sizeof(RangeInfo) * numRangeInfos);
        void* voidPtr = alloc.AllocateWithAlignment(
            alignof(TypeMaskTy),
            presize + offsetof_member_v<&DfgComplexNodePredictionPropagationData::m_predictions> + sizeof(TypeMaskTy) * numOutputs);

        DfgComplexNodePredictionPropagationData* p = reinterpret_cast<DfgComplexNodePredictionPropagationData*>(reinterpret_cast<uint8_t*>(voidPtr) + presize);
        return p;
    }

    void ALWAYS_INLINE SetInputMaskVal(size_t idx, uint64_t val)
    {
        reinterpret_cast<uint64_t*>(m_inputMaskAddrs)[idx] = val;
    }

    __attribute__((__packed__)) TypeMaskTy** m_inputMaskAddrs;
    TypeMaskTy m_predictions[0];
};
static_assert(alignof(DfgComplexNodePredictionPropagationData) == alignof(TypeMaskTy));

// Layout:
// [ InputMasks... ] [ predictions... ]
//
struct DfgSimpleNodePredictionPropagationData
{
    // Not aligned, so return uint8_t*
    //
    uint8_t* ALWAYS_INLINE GetInputMaskAddrArrayStart(size_t numInputs)
    {
        return reinterpret_cast<uint8_t*>(this) - sizeof(uint64_t) * numInputs;
    }

    TypeMaskTy* ALWAYS_INLINE GetInputMaskAddr(size_t idx)
    {
        return UnalignedLoad<TypeMaskTy*>(reinterpret_cast<TypeMaskTy**>(this) - (idx + 1));
    }

    void ALWAYS_INLINE SetInputMaskVal(size_t idx, uint64_t val)
    {
        UnalignedStore<uint64_t>(reinterpret_cast<uint64_t*>(this) - (idx + 1), val);
    }

    static DfgSimpleNodePredictionPropagationData* WARN_UNUSED Create(TempArenaAllocator& alloc,
                                                                      size_t numInputMasks,
                                                                      size_t numOutputs)
    {
        TestAssert(numOutputs > 0);
        static_assert(sizeof(uint64_t) % sizeof(TypeMaskTy) == 0);
        size_t presize = sizeof(uint64_t) * numInputMasks;
        void* voidPtr = alloc.AllocateWithAlignment(
            alignof(TypeMaskTy),
            presize + sizeof(TypeMaskTy) * numOutputs);

        DfgSimpleNodePredictionPropagationData* p = reinterpret_cast<DfgSimpleNodePredictionPropagationData*>(reinterpret_cast<uint8_t*>(voidPtr) + presize);
        return p;
    }

    TypeMaskTy m_predictions[0];
};

// The data structure passed to the per-node prediction propagation initialization function, and also used by it to return data back
//
struct DfgPredictionPropagationSetupInfo
{
    // The memory holding the prediction propagation results will be valid as long as 'resultAlloc' is live
    // so 'tempAlloc' can be discarded after prediction propagation finishes
    //
    DfgPredictionPropagationSetupInfo(TempArenaAllocator& resultAlloc,
                                      TempArenaAllocator& tempAlloc)
        : m_resultAlloc(resultAlloc)
        , m_tempAlloc(tempAlloc)
        , m_valueProfileOrds(tempAlloc)
    { }

    TempArenaAllocator& m_resultAlloc;
    TempArenaAllocator& m_tempAlloc;

    // Either a DfgComplexNodePredictionPropagationData or a DfgSimpleNodePredictionPropagationData
    // Caller only needs to pass this pointer to the prediction propagation function, so it does not care about the actual type
    //
    void* m_data;

    // Caller should interpret m_inputOrds as an uint64_t*, and modify m_inputOrds[k] to the actual pointer.
    // If m_inputOrds[k] is -1, m_inputOrds[k] should be changed to nullptr.
    // Otherwise, m_inputOrds[k] should be changed to the prediction field for input k.
    //
    // Note that m_inputOrds may not be aligned properly
    //
    size_t m_inputListLen;
    void* m_inputOrds;

    // The array of predictions for each output value
    //
    TypeMaskTy* m_predictions;

    // Caller should initialize m_predictions[m_valueProfileOrds[k]] to valueProfile[k]
    //
    TempVector<uint32_t> m_valueProfileOrds;
};

using DfgPredictionPropagationImplFuncTy = bool(*)(void* /*data*/, void* /*nsd*/);
